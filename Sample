// GenericQueryService.java
import org.springframework.stereotype.Service;

import javax.persistence.EntityManager;
import javax.persistence.Query;
import java.util.List;

@Service
public class GenericQueryService {

    private final EntityManager entityManager;

    public GenericQueryService(EntityManager entityManager) {
        this.entityManager = entityManager;
    }

    public List<Object[]> executeDynamicQuery(String dynamicSql) {
        Query query = entityManager.createNativeQuery(dynamicSql);
        return query.getResultList();
    }
}


// QueryClient.java
import com.google.inject.Inject;
import org.springframework.stereotype.Component;

import java.util.List;

@Component
public class QueryClient {

    private final GenericQueryService genericQueryService;

    @Inject
    public QueryClient(GenericQueryService genericQueryService) {
        this.genericQueryService = genericQueryService;
    }

    public void executeQuery(String dynamicSql) {
        // Execute dynamic SQL query using GenericQueryService
        List<Object[]> result = genericQueryService.executeDynamicQuery(dynamicSql);

        // Process the result as needed
        result.forEach(row -> {
            // Process each row of the result
            // Example: System.out.println(Arrays.toString(row));
        });
    }
}

// GuiceModule.java
import com.google.inject.AbstractModule;
import com.google.inject.persist.jpa.JpaPersistModule;

import javax.persistence.EntityManager;

public class GuiceModule extends AbstractModule {

    @Override
    protected void configure() {
        install(new JpaPersistModule("myJpaUnit"));

        // Bind EntityManager
        bind(EntityManager.class).toProvider(JpaPersistModule.class).asEagerSingleton();

        // Bind GenericQueryService
        bind(GenericQueryService.class).asEagerSingleton();
        
        // Bind QueryClient
        bind(QueryClient.class).asEagerSingleton();
    }
}

To populate data in PostgreSQL based on the provided Hazelcast data populator class, you'll need to create corresponding tables in PostgreSQL and insert data into those tables. Below is an example of how you can modify your code to achieve this using Spring Data JPA:

1. **Create Entity Classes for PostgreSQL:**

```java
// EmployeeEntity.java
import javax.persistence.Entity;
import javax.persistence.Id;

@Entity
public class EmployeeEntity {
    @Id
    private Integer employeeId;
    private String employeeName;
    private Integer departmentId;
    private Integer projectId;
    private Integer salary;
    // getters and setters
}
```

```java
// DepartmentEntity.java
import javax.persistence.Entity;
import javax.persistence.Id;

@Entity
public class DepartmentEntity {
    @Id
    private Integer departmentId;
    private String departmentName;
    // getters and setters
}
```

```java
// ProjectEntity.java
import javax.persistence.Entity;
import javax.persistence.Id;

@Entity
public class ProjectEntity {
    @Id
    private Integer projectId;
    private String projectName;
    // getters and setters
}
```

2. **Create Spring Data JPA Repositories for PostgreSQL:**

```java
// EmployeeRepository.java
import org.springframework.data.jpa.repository.JpaRepository;

public interface EmployeeRepository extends JpaRepository<EmployeeEntity, Integer> {
}
```

```java
// DepartmentRepository.java
import org.springframework.data.jpa.repository.JpaRepository;

public interface DepartmentRepository extends JpaRepository<DepartmentEntity, Integer> {
}
```

```java
// ProjectRepository.java
import org.springframework.data.jpa.repository.JpaRepository;

public interface ProjectRepository extends JpaRepository<ProjectEntity, Integer> {
}
```

3. **Modify DataPopulator to use Spring Data JPA Repositories:**

```java
// DataPopulator.java
import org.springframework.stereotype.Component;

import java.util.List;

@Component
public class DataPopulator {

    private final EmployeeRepository employeeRepository;
    private final DepartmentRepository departmentRepository;
    private final ProjectRepository projectRepository;

    public DataPopulator(EmployeeRepository employeeRepository,
                         DepartmentRepository departmentRepository,
                         ProjectRepository projectRepository) {
        this.employeeRepository = employeeRepository;
        this.departmentRepository = departmentRepository;
        this.projectRepository = projectRepository;
    }

    public void populatePostgresTables() {
        // Populate employees table
        addEmployeeRecord(1, "A", 1, 1, 80000);
        addEmployeeRecord(2, "B", 2, 1, 90000);
        addEmployeeRecord(3, "C", 1, 2, 75000);
        addEmployeeRecord(4, "D", 2, 2, 85000);

        // Populate departments table
        addDepartmentRecord(1, "HR");
        addDepartmentRecord(2, "Engineering");

        // Populate projects table
        addProjectRecord(1, "ProjectA");
        addProjectRecord(2, "ProjectB");
    }

    private void addEmployeeRecord(Integer employeeId, String employeeName, Integer departmentId,
                                   Integer projectId, Integer salary) {
        EmployeeEntity employeeEntity = new EmployeeEntity();
        employeeEntity.setEmployeeId(employeeId);
        employeeEntity.setEmployeeName(employeeName);
        employeeEntity.setDepartmentId(departmentId);
        employeeEntity.setProjectId(projectId);
        employeeEntity.setSalary(salary);
        employeeRepository.save(employeeEntity);
    }

    private void addDepartmentRecord(Integer departmentId, String departmentName) {
        DepartmentEntity departmentEntity = new DepartmentEntity();
        departmentEntity.setDepartmentId(departmentId);
        departmentEntity.setDepartmentName(departmentName);
        departmentRepository.save(departmentEntity);
    }

    private void addProjectRecord(Integer projectId, String projectName) {
        ProjectEntity projectEntity = new ProjectEntity();
        projectEntity.setProjectId(projectId);
        projectEntity.setProjectName(projectName);
        projectRepository.save(projectEntity);
    }
}
```

4. **Guice Configuration:**

Modify your Guice module to include the repositories and the data populator:

```java
// GuiceModule.java
import com.google.inject.AbstractModule;
import com.google.inject.persist.jpa.JpaPersistModule;

import javax.persistence.EntityManager;

public class GuiceModule extends AbstractModule {

    @Override
    protected void configure() {
        install(new JpaPersistModule("myJpaUnit"));

        // Bind EntityManager
        bind(EntityManager.class).toProvider(JpaPersistModule.class).asEagerSingleton();

        // Bind Spring Data JPA Repositories
        bind(EmployeeRepository.class).asEagerSingleton();
        bind(DepartmentRepository.class).asEagerSingleton();
        bind(ProjectRepository.class).asEagerSingleton();

        // Bind DataPopulator
        bind(DataPopulator.class).asEagerSingleton();
        
        // Bind QueryClient
        bind(QueryClient.class).asEagerSingleton();
    }
}
```

Now, your `DataPopulator` class uses Spring Data JPA repositories to populate data into PostgreSQL tables. Adjust the code according to your specific requirements and configurations. Make sure that your Spring Data JPA configuration is correctly set up in your Spring Boot application.


<!-- Spring Boot Starter Data JPA -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-jpa</artifactId>
    <version>2.6.2</version>
</dependency>

<!-- PostgreSQL Driver -->
<dependency>
    <groupId>org.postgresql</groupId>
    <artifactId>postgresql</artifactId>
    <version>42.2.24</version>
</dependency>

<!-- Spring Boot Starter for Guice -->
<dependency>
    <groupId>com.github.springboot-guice</groupId>
    <artifactId>spring-boot-guice</artifactId>
    <version>1.1.0</version>
</dependency>

<!-- Spring Boot Starter Test (for testing) -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <version>2.6.2</version>
    <scope>test</scope>
</dependency>


<!-- Guice Spring Boot Starter -->
<dependency>
    <groupId>com.google.inject.extensions</groupId>
    <artifactId>guice-spring-boot-starter</artifactId>
    <version>1.0.2</version>
</dependency>


Certainly! Assuming you have the entities `EmployeeEntity`, `DepartmentEntity`, and `ProjectEntity` representing your PostgreSQL tables, and you want to perform a join query, here's an example of how you can create a method in your `GenericQueryService` to execute the join query:

1. **Update GenericQueryService:**

```java
// GenericQueryService.java
import org.springframework.stereotype.Service;

import javax.persistence.EntityManager;
import javax.persistence.Query;
import java.util.List;

@Service
public class GenericQueryService {

    private final EntityManager entityManager;

    public GenericQueryService(EntityManager entityManager) {
        this.entityManager = entityManager;
    }

    public List<Object[]> executeJoinQuery(String dynamicSql) {
        Query query = entityManager.createNativeQuery(dynamicSql);
        return query.getResultList();
    }
}
```

2. **Create a method in QueryClient to execute the join query:**

```java
// QueryClient.java
import com.google.inject.Inject;
import org.springframework.stereotype.Component;

import java.util.List;

@Component
public class QueryClient {

    private final GenericQueryService genericQueryService;

    @Inject
    public QueryClient(GenericQueryService genericQueryService) {
        this.genericQueryService = genericQueryService;
    }

    public void executeJoinQueryAndPrintResult() {
        // Define your join query dynamically
        String joinQuery = "SELECT e.employee_id, e.employee_name, d.department_name, p.project_name " +
                           "FROM EmployeeEntity e " +
                           "JOIN DepartmentEntity d ON e.department_id = d.department_id " +
                           "JOIN ProjectEntity p ON e.project_id = p.project_id";

        // Execute join query using GenericQueryService
        List<Object[]> result = genericQueryService.executeJoinQuery(joinQuery);

        // Print the result in a pretty format
        System.out.println("Result of Join Query:");
        System.out.println("==============================================");
        for (Object[] row : result) {
            System.out.printf("Employee ID: %s, Employee Name: %s, Department: %s, Project: %s%n",
                    row[0], row[1], row[2], row[3]);
        }
        System.out.println("==============================================");
    }
}
```

3. **Guice Configuration:**

Ensure that your Guice configuration is properly set up, including the `GenericQueryService` and `QueryClient`.

Now, you can call `executeJoinQueryAndPrintResult()` in your application to execute the join query and print the result in a pretty format. Adjust the SQL query based on your actual database schema and requirements.

Certainly! To measure the time taken for the execution, you can use the `System.currentTimeMillis()` method before and after the execution of the query. Additionally, I'll provide configuration parameters assuming you have a PostgreSQL database installed locally.

1. **Update GenericQueryService with timing:**

```java
// GenericQueryService.java
import org.springframework.stereotype.Service;

import javax.persistence.EntityManager;
import javax.persistence.Query;
import java.util.List;

@Service
public class GenericQueryService {

    private final EntityManager entityManager;

    public GenericQueryService(EntityManager entityManager) {
        this.entityManager = entityManager;
    }

    public List<Object[]> executeJoinQuery(String dynamicSql) {
        long startTime = System.currentTimeMillis();

        Query query = entityManager.createNativeQuery(dynamicSql);
        List<Object[]> result = query.getResultList();

        long endTime = System.currentTimeMillis();
        System.out.println("Query executed in " + (endTime - startTime) + " milliseconds.");

        return result;
    }
}
```

2. **Update QueryClient with PostgreSQL configuration:**

Assuming you have a PostgreSQL database installed locally, you need to provide the necessary configuration in your `application.properties` file:

```properties
# application.properties

# DataSource settings: set PostgreSQL properties
spring.datasource.url=jdbc:postgresql://localhost:5432/your_database_name
spring.datasource.username=your_username
spring.datasource.password=your_password

# Specify the database platform
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# Hibernate ddl auto (create, create-drop, validate, update)
spring.jpa.hibernate.ddl-auto=update

# Logging SQL statements
spring.jpa.show-sql=true
```

Replace `your_database_name`, `your_username`, and `your_password` with your actual database name, username, and password.

3. **Guice Configuration:**

Make sure your Guice configuration is correctly set up to include the necessary components, including `GenericQueryService` and `QueryClient`.

Now, when you run your application, it will execute the join query, print the result, and display the time taken for the execution. Adjust the configuration parameters according to your PostgreSQL setup.


